# Bug Hunt Report - 2025-12-16

Comprehensive security, data integrity, and deployment bug analysis for Nervous CRM.

---

## Critical Issues

### 1. Missing Foreign Key Constraint on Contact.ownerId
**Location:** `prisma/schema.prisma:166`

**Issue:** The `Contact.owner` relation does NOT have `onDelete` behavior defined, while similar fields do.

```prisma
owner      User       @relation("ContactOwner", fields: [ownerId], references: [id])
```

**Impact:** If a user is deleted, contacts owned by that user will have dangling foreign keys, causing database constraint violations and application crashes.

**Comparison:** Deal.owner has no onDelete either (line 198), but Activity.user (line 238) also lacks onDelete behavior.

**Fix Required:** Add `onDelete: Cascade` or `onDelete: SetNull` (with nullable ownerId) to prevent orphaned records.

---

### 2. Audit Log Using Non-Existent 'system' Team ID
**Location:** `src/services/audit.service.ts:64`

**Issue:** Security events use a hardcoded 'system' teamId that doesn't exist in the database:

```typescript
await prisma.auditLog.create({
  data: {
    teamId: 'system', // Special ID for system-wide security events
    ...
  },
});
```

**Impact:** This will fail with a foreign key constraint violation if AuditLog has a foreign key to Team (which it should). If there's no FK constraint, this creates orphaned data that can't be queried properly.

**Fix Required:** Either:
- Create a nullable `teamId` field in AuditLog
- Create an actual 'system' team in migrations
- Use a separate table for security events

---

### 3. Missing Database Migration Constraint Checks
**Location:** `prisma/migrations/`

**Issue:** Only 2 migrations exist, but schema has critical constraints that may not be enforced:
- `@@unique([teamId, name])` on Company (line 144)
- `@@unique([teamId, email])` on Contact (line 170)

**Impact:** If these constraints aren't in the actual database, data corruption is possible. Multiple companies with same name in a team, or multiple contacts with same email.

**Verification Needed:** Check if migration files contain these constraint definitions.

---

### 4. Race Condition in Session Creation
**Location:** `src/services/auth.service.ts:405-426`

**Issue:** Session is created with empty refreshToken placeholder, then updated:

```typescript
const session = await tx.session.create({
  data: {
    userId,
    refreshToken: '', // Temporary placeholder
    expiresAt: getRefreshTokenExpiry(),
  },
});
```

**Impact:** Brief window where session exists with empty refresh token. If the token generation fails or transaction is interrupted, session is left in invalid state. Refresh token rotation may fail.

**Fix Required:** Generate refresh token before creating session, or handle empty refresh tokens gracefully.

---

### 5. Contact Update Allows Setting Nullable Company/Owner Without Validation
**Location:** `src/services/contact.service.ts:107-135`

**Issue:** When updating a contact, if `companyId` or `ownerId` is explicitly set to `null` or empty string, the validation checks are skipped:

```typescript
if (input.companyId) {
  await validateTeamCompany(teamId, input.companyId);
}
```

**Impact:** Could potentially bypass team validation by sending empty string or other falsy values that pass the `if` check but aren't actually null.

---

## High Severity Issues

### 6. No Cascade Delete Protection on Deal/Activity When Contact is Soft-Deleted
**Location:** `src/services/contact.service.ts:138-152`

**Issue:** Contacts are soft-deleted (setting deletedAt), but Deals and Activities reference contacts with `onDelete: SetNull`. This creates inconsistency:

```typescript
await prisma.contact.update({
  where: { id },
  data: { deletedAt: new Date() },
});
```

**Impact:** Deals and activities will still reference "deleted" contacts. Queries must always filter by `deletedAt: null`, but some queries may miss this. Could show deleted contact data.

**Fix Required:** Either:
- Also soft-delete related deals/activities
- Set dealId/contactId to null on related records
- Add application-level checks for deleted contacts in all queries

---

### 7. Company Unique Constraint Can Be Bypassed via Soft Delete
**Location:** `prisma/schema.prisma:144` and `src/services/company.service.ts:90-103`

**Issue:** Company has `@@unique([teamId, name])` constraint, but soft delete only sets `deletedAt`:

```typescript
await prisma.company.update({
  where: { id },
  data: { deletedAt: new Date() },
});
```

**Impact:** Cannot create a new company with the same name as a deleted one in the same team. Unique constraint violation.

**Fix Required:**
- Use hard deletes for companies
- Include deletedAt in unique constraint (requires migration)
- Add logic to handle name conflicts with deleted companies

---

### 8. Missing Error Handling in AuthContext Refresh
**Location:** `web/src/contexts/AuthContext.tsx:28-35`

**Issue:** Silent error swallowing in refreshUser:

```typescript
try {
  const response = await api.get<{ data: User }>('/users/me');
  setUser(response.data);
} catch {
  setUser(null); // Silently fails - no error indication
}
```

**Impact:** If `/users/me` fails due to network issues, users are logged out with no error message. Cannot distinguish between unauthorized and network errors.

**Fix Required:** Implement proper error handling and user feedback.

---

### 9. Invite Token Exposure in API Response
**Location:** `src/api/teams/teams.routes.ts:59-68`

**Issue:** The invite token is returned in the API response:

```typescript
return {
  data: {
    id: invite.id,
    email: invite.email,
    role: invite.role,
    token: invite.token, // Frontend will use this to construct invite link
    expiresAt: invite.expiresAt,
  },
};
```

**Impact:** If an attacker gains access to the API response (XSS, MITM), they can steal invite tokens. Tokens should be sent via email, not returned in API response.

**Fix Required:** Only return token in development mode, require email sending in production.

---

### 10. No Transaction Wrapping for Deal Stage Changes
**Location:** `src/services/deal.service.ts:155-201`

**Issue:** Deal update including stage change and closedAt timestamp is not atomic:

```typescript
return prisma.deal.update({
  where: { id },
  data: {
    ...input,
    stage: input.stage as DealStage | undefined,
    ...(closedAt !== undefined && { closedAt }),
  },
  ...
});
```

**Impact:** If multiple concurrent updates occur, race condition can result in incorrect closedAt timestamps or stage/closedAt mismatches.

---

### 11. Password Reset Token Enumeration via Timing Attack
**Location:** `src/services/auth.service.ts:228-261`

**Issue:** Even though a fake token is returned for non-existent users, the database operations create timing differences:

```typescript
if (!user) {
  return { token: generateSecureToken() }; // Fast - no DB write
}
// Slow - DB writes for existing user
```

**Impact:** Attacker can determine if an email exists by measuring response time.

**Fix Required:** Add consistent timing delays or always perform DB operations.

---

## Medium Severity Issues

### 12. Missing Null Check in Deal Pipeline Value Calculation
**Location:** `src/services/deal.service.ts:85-88`

**Issue:** Uses `.toNumber()` on Decimal which may be null:

```typescript
const totalValue = deals.reduce(
  (sum, deal) => sum + (deal.value?.toNumber() || 0),
  0
);
```

**Impact:** While the `|| 0` handles it, if Prisma returns `null` instead of `undefined` for nullable Decimals, this could throw. Defensive but not guaranteed safe.

---

### 13. Inconsistent Soft Delete Filtering
**Location:** Multiple service files

**Issue:** Some queries filter `deletedAt: null`, others don't:
- `company.service.ts:14` - filters deletedAt ✓
- `contact.service.ts:16` - filters deletedAt ✓
- But validation helpers in `validation.ts:33, 47, 62` also check deletedAt

**Impact:** Inconsistent - could lead to soft-deleted records being used in validations if any query misses the filter.

**Audit Needed:** Verify ALL queries include `deletedAt: null` filter.

---

### 14. Team Member Deletion Causes Data Orphaning
**Location:** `src/services/team.service.ts:97-115`

**Issue:** When removing a team member, their owned contacts/deals become orphaned:

```typescript
await prisma.user.delete({ where: { id: userId } });
```

**Impact:** Because Contact.ownerId and Deal.ownerId don't have `onDelete` behavior, this will fail with foreign key constraint violation. User cannot be deleted if they own any records.

**Fix Required:** Either:
- Reassign owned records before deletion
- Add `onDelete: Cascade` to cascade delete everything
- Add `onDelete: SetNull` with nullable owner fields

---

### 15. No Rate Limiting on CSRF Token Endpoint
**Location:** `src/server.ts:80-83`

**Issue:** CSRF token endpoint has no rate limiting:

```typescript
fastify.get('/api/v1/csrf-token', async (_request, reply) => {
  const token = await reply.generateCsrf();
  return { data: { csrfToken: token } };
});
```

**Impact:** Can be abused to generate unlimited CSRF tokens, potentially exhausting server resources or enabling attacks.

**Fix Required:** Add rate limiting to this endpoint.

---

### 16. Missing Index on AuditLog.createdAt
**Location:** `prisma/schema.prisma:279`

**Issue:** AuditLog queries order by createdAt but index is defined:

```prisma
@@index([createdAt])
```

**Status:** Actually this EXISTS in schema - NOT A BUG. Keeping for verification.

---

### 17. Activity Update Allows Partial Nullification Without Validation
**Location:** `src/services/activity.service.ts:116-151`

**Issue:** Activity update uses spread pattern that could allow setting dealId/contactId to null without checks:

```typescript
...(input.dealId !== undefined && { dealId: input.dealId }),
```

**Impact:** If `input.dealId` is explicitly `null`, it bypasses validation. Depends on schema validation.

---

### 18. No Database Connection Error Handling in Prisma Client
**Location:** `src/db/client.ts:1-17`

**Issue:** Prisma client is created but no connection error handling:

```typescript
export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
  });
```

**Impact:** If database is unreachable at startup, app may start but fail on first query with unclear error.

**Fix Required:** Add connection verification in startup or better error handling.

---

### 19. Email Verification Not Required for Critical Actions
**Location:** `prisma/schema.prisma:37`

**Issue:** User.emailVerified exists but is not checked anywhere in authorization:

```prisma
emailVerified Boolean   @default(false)
```

**Impact:** Unverified users can perform all actions. If email verification is intended as a security measure, it's not enforced.

---

### 20. Deal Probability Default May Conflict With Business Logic
**Location:** `prisma/schema.prisma:185`

**Issue:** Deal probability defaults to 0, but may be illogical for certain stages:

```prisma
probability Int?      @default(0)
```

**Impact:** A deal in "negotiation" stage with 0% probability doesn't make business sense. May need stage-based defaults.

---

## Low Severity Issues

### 21. Inconsistent DateTime Handling in Activity Queries
**Location:** `src/services/activity.service.ts:35-36`

**Issue:** Query parameters come as strings but are used directly in Date comparisons:

```typescript
...(dueBefore && { dueAt: { lte: dueBefore } }),
...(dueAfter && { dueAt: { gte: dueAfter } }),
```

**Impact:** Depends on schema validation to parse strings to Date. If validation is skipped, could cause type errors.

---

### 22. No Cleanup Job for Expired Sessions
**Location:** `prisma/schema.prisma:53-65`

**Issue:** Session table has expiresAt but no automated cleanup:

```prisma
expiresAt    DateTime
```

**Impact:** Database will accumulate expired sessions indefinitely. Performance degradation over time.

**Fix Required:** Add cron job or scheduled task to delete expired sessions.

---

### 23. No Cleanup Job for Expired Invites
**Location:** `prisma/schema.prisma:67-83`

**Issue:** Invite table tracks expiration but no cleanup:

```prisma
expiresAt DateTime
```

**Impact:** Similar to sessions, expired invites accumulate.

---

### 24. Missing Request ID for Tracing
**Location:** `src/server.ts`

**Issue:** No request ID generation for distributed tracing.

**Impact:** Difficult to trace requests across logs and services.

---

### 25. CORS Configuration May Be Too Permissive in Development
**Location:** `src/server.ts:35-38`

**Issue:** CORS origin is set to `config.frontendUrl`:

```typescript
fastify.register(cors, {
  origin: config.frontendUrl,
  credentials: true,
});
```

**Impact:** If `FRONTEND_URL` is misconfigured or set to `*`, credentials could be exposed. Defaults to localhost in dev.

---

### 26. No Input Sanitization for Search Queries
**Location:** Multiple service files (e.g., `company.service.ts:17-18`)

**Issue:** Search uses Prisma `contains` with user input:

```typescript
{ name: { contains: search, mode: 'insensitive' } },
```

**Impact:** While Prisma protects against SQL injection, no sanitization for special characters. Could affect performance with regex-like patterns.

---

### 27. Activity Toggle Complete Has Race Condition
**Location:** `src/services/activity.service.ts:154-173`

**Issue:** Read-then-update pattern:

```typescript
const activity = await prisma.activity.findFirst(...);
return prisma.activity.update({
  data: {
    completedAt: activity.completedAt ? null : new Date(),
  },
});
```

**Impact:** If two requests toggle concurrently, both read same state and write same result. Could lose one toggle.

**Fix Required:** Use optimistic locking or single atomic update.

---

### 28. No Logging of Authorization Failures
**Location:** `src/lib/auth.ts:17-41`

**Issue:** Auth middleware returns 401 but doesn't log failures:

```typescript
return reply.status(401).send({
  error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
});
```

**Impact:** Cannot detect brute force attempts or security probes.

---

### 29. Frontend API Error Messages Not User-Friendly
**Location:** `web/src/lib/api.ts:59-65`

**Issue:** Generic error message on network failure:

```typescript
const error = await response.json().catch(() => ({ error: { message: 'Network error' } }));
```

**Impact:** Users see unhelpful "Network error" for all failures including 500s.

---

### 30. Missing Validation for Deal Value Range
**Location:** Schema validation (not reviewed in detail)

**Issue:** Deal value is `Decimal(12, 2)` but no validation for reasonable ranges.

**Impact:** Could allow absurdly large or negative values if schema validation is missing.

---

## Data Integrity Concerns

### 31. Soft Delete Inconsistency Across Relations
**Summary:** Companies, Contacts, Deals, and Activities use soft delete, but:
- Parent deletion doesn't cascade soft delete to children
- Queries must manually filter `deletedAt: null` everywhere
- Risk of showing "deleted" data if any query forgets the filter

**Recommendation:** Implement application-level cascade soft delete or use database triggers.

---

### 32. No Audit Trail for Soft Deletes
**Location:** Soft delete operations in services

**Issue:** Soft deletes don't create audit log entries.

**Impact:** Cannot track who deleted what and when.

---

## Deployment Risks

### 33. Production Environment Variables Not Validated at Runtime
**Location:** `src/lib/config.ts`

**Status:** Actually, config IS validated - this is GOOD. No bug here.

---

### 34. No Database Migration Verification in Deployment
**Issue:** No automated check that migrations are applied before starting server.

**Impact:** Server can start with mismatched schema, causing runtime errors.

**Fix Required:** Add migration check in startup script or CI/CD.

---

### 35. Missing Health Check for Database
**Location:** `src/server.ts:75-77`

**Issue:** Health check returns success without checking database connectivity:

```typescript
fastify.get('/health', async () => {
  return { status: 'ok' };
});
```

**Impact:** Load balancer may route traffic to instance with broken DB connection.

**Fix Required:** Add DB ping to health check.

---

## Testing Gaps

### 36. No Tests for Concurrent Operations
**Issue:** No tests for race conditions in:
- Session creation
- Deal stage updates
- Activity toggles
- User deletion vs record ownership

**Impact:** Race conditions will only manifest in production under load.

---

### 37. No Tests for Soft Delete Cascades
**Issue:** No verification that soft deleting a company properly handles related contacts/deals.

---

## Summary Statistics

- **Critical Issues:** 5 (could cause data loss or production crashes)
- **High Severity:** 6 (security or data integrity risks)
- **Medium Severity:** 13 (potential bugs or edge cases)
- **Low Severity:** 13 (code quality and observability)

## Recommended Immediate Actions

1. **Fix foreign key constraints** on Contact.ownerId, Deal.ownerId, Activity.userId
2. **Fix audit log 'system' teamId** issue
3. **Add cascade soft delete logic** for related records
4. **Verify database migrations** include all unique constraints
5. **Add database health check** to deployment
6. **Fix session creation race condition**
7. **Implement proper error handling** in frontend AuthContext
8. **Add rate limiting** to CSRF endpoint
9. **Review and fix company unique constraint** with soft deletes
10. **Add cleanup jobs** for expired sessions and invites
